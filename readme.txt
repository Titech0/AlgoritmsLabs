Дерево бінарного пошуку (наївна реалізація, без балансування)

1. Написати клас (BSTNode) для зберігання дерева бінарного пошуку з цілими ключами та строковими значеннями.
Він повинен містити такі методи:
- Вставка (ключ, значення). Якщо такий ключ вже є – значення перезаписується
- Видалення по ключу
- пошук по ключу
- обхід дерева від кореня

2. Написати тестовий код для цього класу (в java краще використовувати jUnit та юніт тести), який перевіряє коректність виконання основних операцій.

Тесткейси:
	1. Створити Map із 20 елементів для зберігання тестових даних ключами служать цілі цифри від вашого номера у списку групи N до N+20, структура має бути НЕ ВІДСОРТОВАНА за ключами. Тобто вставлятися дані мають у випадковому порядку.
	2. З даних у структурі створити дерево BSTNode, обійти дерево і перевірити, що кількість вузлів дорівнює 20
	3. Створити дерево із п. 1.,
		- Знайти кілька існуючих елементів за ключами, вивести їх значення.
		- Спробувати знайти неіснуючий елемент, переконатися, що структура повертає Null.
	4. Створити дерево з п. 1., попередньо викинувши з нього один із ключів у середині. Тобто в отриманому дереві повинен бути відсутнім один елемент порівняно з Map, краще, якщо це значення з середини діапазону.
		- Вставити новий елемент із цим пропущеним ключем.
		- Провести пошук по цьому ключу, переконатися, що елемент присутній у дереві
		- Вставити елемент із вже існуючим ключем, але іншим значенням рядка
		- провести обхід дерева, перевірити, що кількість вузлів дорівнює 20
		- Провести пошук по цьому ключу і переконатися, що значення оновилося
	5. Створити дерево із п. 1.
		- Видалити елемент із ключем із середини списку.
		- провести обхід дерева, перевірити, що кількість вузлів дорівнює 19
		- Провести пошук по цьому ключу, переконатися, що елемент відсутній, і метод повертає null

	Всі перевірки значень робити за допомогою Assert